import matplotlib.pyplot as plt
import streamlit as st
import pandas as pd 
import seaborn as sns 
from scipy.stats import chi2_contingency
import numpy as np
from x105Shared import load_data 

    

diabetes, var_dict = load_data()

int_columns = var_dict["int_columns"]
string_columns = var_dict["string_columns"]
ordinal_orders = var_dict["ordinal_orders"]

hm1 = st.selectbox('Column', diabetes.columns, key='count_heatmap_column', index=2)
hm2 = st.selectbox('Row', diabetes.columns, key='count_heatmap_row', index=1)
tt = pd.crosstab(diabetes[hm1], diabetes[hm2])

plt.clf()      # clear current figure
plt.figure()   # start a new figure
ax = sns.heatmap(tt)
fig = ax.get_figure()

st.pyplot(fig)

# ok so for like the correlation plots essentially we care about whether they're ordinal or not
@st.cache_data
def plot_static_correlations():
    ordinal_columns = int_columns
    categorical_columns = string_columns

    corr_diabetes = diabetes.copy()

    for c in ordinal_orders:
        corr_diabetes[c + "_code"] = corr_diabetes[c].cat.codes
        # corr_diabetes.drop(c, inplace=True, axis=1)
        

    ordinal_columns = ordinal_columns + [c + "_code" for c in ordinal_orders]
    nominal_columns = categorical_columns
    nominal_columns = [c for c in nominal_columns if not c in ["age","encounter_id","patient_nbr"]]
    # nominal_columns.remove("readmitted") # here we kind of treat readmitted as both nominal and ordinal (by interpreting No as \infinite readmission time)

    #hc1 = st.selectbox('Column', ordinal_columns, key='count_heatmap_column', index=2)
    #hc2 = st.selectbox('Row', ordinal_columns, key='count_heatmap_row', index=1)


    corr_df = corr_diabetes[ordinal_columns]
    corr = corr_df.corr(method="spearman")

    plt.clf()      # clear current figure
    plt.figure()   # start a new figure
    ax = sns.heatmap(corr)
    fig = ax.get_figure()


    st.title('Correlations')
    st.caption('Nb readmission is treated both as a ordinal variable by interpreting no readmission as an readmission duration of infinity, as as a nominal variable by treating the three readmission categories as unordered categories.')
    st.subheader('Ordinal-ordinal correlations')
    st.caption("Calculated using Pandas Spearman correlation")
    st.pyplot(fig)


    # generated by ChatGPT, copied and pasted wholesale
    def cramers_v(x: pd.Series, y: pd.Series) -> float:
        """
        Bias-corrected Cramér's V for two nominal variables (0..1).
        """
        table = pd.crosstab(x, y)
        if table.size == 0:
            return np.nan

        chi2, _, _, _ = chi2_contingency(table, correction=False)
        n = table.values.sum()
        if n == 0:
            return np.nan

        phi2 = chi2 / n
        r, k = table.shape
        # Bias correction (Bergsma & Wicher, 2013)
        phi2_corr = max(0, phi2 - (k-1)*(r-1)/(n-1)) if n > 1 else 0
        r_corr = r - (r-1)**2/(n-1) if n > 1 else r
        k_corr = k - (k-1)**2/(n-1) if n > 1 else k
        denom = min((k_corr-1), (r_corr-1))
        return np.sqrt(phi2_corr / denom) if denom > 0 else 0.0

    # adapted from ChatGPT
    cm = pd.DataFrame(index=nominal_columns, columns=nominal_columns, dtype=float)
    for a in nominal_columns:
        for b in nominal_columns:
            cm.loc[a, b] = cramers_v(corr_diabetes[a], corr_diabetes[b])



    st.subheader('Nominal-nominal correlations')
    st.caption("Calculated using ChatGPT-generated Cramer's V function ")

    plt.clf()      # clear current figure
    plt.figure()   # start a new figure
    ax = sns.heatmap(cm.astype(float))
    fig = ax.get_figure()
    st.pyplot(fig)

    # generated by ChatGPT, copied and pasted wholesale
    def correlation_ratio(categories: pd.Series, values: pd.Series) -> float:
        """
        Correlation ratio (eta) of nominal categories explaining a numeric variable (0..1).
        η = sqrt( between-group variance / total variance )
        """
        valid = pd.DataFrame({"cat": categories, "val": values}).dropna()
        if valid.empty:
            return np.nan

        y = valid["val"].values
        groups = valid.groupby("cat")["val"]

        overall_mean = y.mean()
        n_total = len(y)

        # Between-group sum of squares
        ss_between = sum(len(g) * (g.mean() - overall_mean)**2 for _, g in groups)
        # Total sum of squares
        ss_total = ((y - overall_mean)**2).sum()

        if ss_total == 0:
            return 0.0  # no variation in numeric -> no relationship measurable
        return float(np.sqrt(ss_between / ss_total))


    eta_mat = pd.DataFrame(index=nominal_columns, columns=ordinal_columns, dtype=float)
    for cat in nominal_columns:
        for num in ordinal_columns:
            eta_mat.loc[cat, num] = correlation_ratio(corr_diabetes[cat], corr_diabetes[num])

    plt.clf()      # clear current figure
    plt.figure()   # start a new figure
    ax = sns.heatmap(eta_mat.astype(float))
    fig = ax.get_figure()
    st.subheader('Nominal-ordinal correlations')
    st.caption("Calculated using ChatGPT-generated eta correlation")
    st.pyplot(fig)


plot_static_correlations()